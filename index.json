[{"content":"The input file in this example Library.fs looks like this:\nnamespace Example open Myriad.Plugins [\u003cGenerator.Fields \"fields\"\u003e] type Test1 = { one: int; two: string; three: float; four: float32 } type Test2 = { one: Test1; two: string } An attribute is used by the fields plugin so that the code generator knows which parts of the input AST should be consumed by the plugin. If you had several records and you only wanted the fields plugin to operate on Test1 then the attribute would be used like in the example about to only apply Generator.Fields to the Test1 record. Note, if you wanted a plugin that just processes the whole input then there is no need to provide such an attribute. Myriad aims to be a library rather than a full framework that ties you to the mechanism used to input and generate code, its up to you how you generate the code, Myriad just aims to help to make this as painless and flexible as possible.\nTo control what namespace is used as well as supplying any other information to plugins a myriad.toml configuration file is used. This is specified in the generator attribute, in the example above you can see the configuration section is fields [\u003cGenerator.Fields \"fields\"\u003e]. The corresponding myriad.toml file looks as follows:\n[fields] namespace = \"TestFields\" The fields plugin uses only a single configuration key namespace to control the resulting namespace the record helpers are generated\nThe fields plugin in this example will generate the following code at prebuild and compile the code into your assembly:\n//------------------------------------------------------------------------------ // This code was generated by myriad. // Changes to this file will be lost when the code is regenerated. //------------------------------------------------------------------------------ namespace rec TestFields module Test1 = open Example let one (x : Test1) = x.one let two (x : Test1) = x.two let three (x : Test1) = x.three let four (x : Test1) = x.four let create (one : Test1) (two : string) (three : float) (four : float32) : Test1 = { one = one two = two three = three four = four } let map (mapone : int -\u003e int) (maptwo : string -\u003e string) (mapthree : float -\u003e float) (mapfour : float32 -\u003e float32) (record': Test1) = { record' with one = mapone record'.one two = maptwo record'.two three = mapthree record'.three four = mapfour record'.four } The fields plugin generates a map for each field in the input record, a create function taking each field, and a map function that takes one function per field in the input record.\nThe map functions for each field are useful in situations where you just want to use a single field from a record in a lambda like a list of records:\nlet records = [{one = \"a\"; two = \"aa\"; three = 42.0; four = 172.0f} {one = \"b\"; two = \"bb\"; three = 42.0; four = 172.0f}] records |\u003e List.sortBy Test1.one ","description":"","tags":null,"title":"Records","uri":"/myriad/docs/plugins/record-fields/"},{"content":"The following are some tutorials about some aspects of myriad\n","description":"","tags":null,"title":"Tutorials","uri":"/myriad/docs/tutorials/"},{"content":"The input file in this example Library.fs looks like this:\nnamespace Example open Myriad.Plugins [\u003cGenerator.DuCases \"dus\" \u003e] type Currency = | CAD | PLN | EUR | USD | Custom of string An attribute is used by the plugin so that the code generator plugin knows which parts of the input AST are to be used by the plugin. If you had several records and you only wanted the fields plugin to operate on Currency then the attribute would be used like in the example about to only apply Generator.DuCases to Currency. Note, if you wanted a plugin that just needs the whole input AST then there is no need to provide an input. Myriad aims to be a library rather than a full framework that ties you to the mechanism used to input and generate code.\nTo control what namespace is used as well as supplying any other information to plugins a myriad.toml configuration file is used. This is specified in the generator attribute, in the example above you can see the configuration section is dus [\u003cGenerator.DuCases \"dus\" \u003e]. The corresponding myriad.toml file looks as follows:\n[dus] namespace = \"TestDus\" The DuCases plugin uses only a single configuration key namespace to control the resulting namespace the DuCases are generated\nThe fields plugin in this example will generate the following code at prebuild time and compile the code into your assembly:\n//------------------------------------------------------------------------------ // This code was generated by myriad. // Changes to this file will be lost when the code is regenerated. //------------------------------------------------------------------------------ namespace rec TestDus module Currency = open Input let toString (x: Currency) = match x with | CAD -\u003e \"CAD\" | PLN -\u003e \"PLN\" | EUR -\u003e \"EUR\" | USD -\u003e \"USD\" | Custom _ -\u003e \"Custom\" let fromString (x: string) = match x with | \"CAD\" -\u003e Some CAD | \"PLN\" -\u003e Some PLN | \"EUR\" -\u003e Some EUR | \"USD\" -\u003e Some USD | _ -\u003e None let toTag (x: Currency) = match x with | CAD -\u003e 0 | PLN -\u003e 1 | EUR -\u003e 2 | USD -\u003e 3 | Custom _ -\u003e 4 let isCAD (x: Currency) = match x with | CAD -\u003e true | _ -\u003e false let isPLN (x: Currency) = match x with | PLN -\u003e true | _ -\u003e false let isEUR (x: Currency) = match x with | EUR -\u003e true | _ -\u003e false let isUSD (x: Currency) = match x with | USD -\u003e true | _ -\u003e false let isCustom (x: Currency) = match x with | Custom _ -\u003e true | _ -\u003e false ","description":"","tags":null,"title":"Discriminated Unions","uri":"/myriad/docs/plugins/du-extensions/"},{"content":"The following are some guides on how to use the different plugins included with Myriad.\n","description":"","tags":null,"title":"Plugins","uri":"/myriad/docs/plugins/"},{"content":"Myriad can also generate lenses for records and single-case discriminated unions. Lens is a pair of a getter and a setter for one property of the type and allows, given the object, to get the value of the property or to update it creating a new object. The advantage of lenses is an ability to combine them to read or update nested fields of the object.\nTo create lenses for your type, first annotate the type for which you want lenses to be generated with Generator.Lenses attribute, note the “lens” parameter specifies which configuration key is used with the plugin, this is used to specify which namespace is generated via the myriad.toml configuration file:\n[\u003cGenerator.Lenses(\"lens\")\u003e] type Record = { one: int two: string } Myriad will generate the following code:\nmodule RecordLenses = let one = (fun (x: Test1) -\u003e x.one), (fun (x: Test1) (value: int) -\u003e { x with one = value }) let two = (fun (x: Test1) -\u003e x.two), (fun (x: Test1) (value: string) -\u003e { x with two = value }) Often lenses are defined as a single-case union around a pair of getter and setter. Myriad is also capable of adding the invocation of such DU’s constructor.\nTo achieve this, add the type Lens to the Generator.Lenses attribute, specifying the name of the DU constructor: [\u003cGenerator.Lenses(\"lens\", \"Lens\")\u003e], and Myriad will generate this code:\nmodule RecordLenses = let one = Lens((fun (x: Test1) -\u003e x.one), (fun (x: Test1) (value: int) -\u003e { x with one = value })) let two = Lens((fun (x: Test1) -\u003e x.two), (fun (x: Test1) (value: string) -\u003e { x with two = value })) You can provide the name of DU constructor in several ways:\nAs a string: [\u003cGenerator.Lenses(\"lens\", \"Lens\")\u003e]; Or as a type: [\u003cGenerator.Lenses(\"lens\", typedefof\u003cLens\u003c_, _\u003e\u003e)\u003e] or [\u003cGenerator.Lenses(\"lens\", typeof\u003cLens\u003c_, _\u003e\u003e)\u003e]. If the Lens type is in different namespace/module than the type decorated with the attribute, provide the full name of the Lens constructor: [\u003cGenerator.Lenses(\"Namespace.And.Module.Of.Lens\")\u003e].\n","description":"","tags":null,"title":"Lenses","uri":"/myriad/docs/plugins/lenses/"},{"content":"Welcome to Myriad Myriad is a code generator, it can take an arbitrary file and uses it to produce F# code. The file can be anything from a plain txt file to an F# file to anything else. Read on to find out more, or visit our documentation to get started!\nHow does Myriad work, how is it different? Myriad is a code generator, in response to an input code can be generated, specifically F# code is generated which means all the various constructs available in F# such as records, discriminated unions, Active patterns etc, can all be generated in response to an input. Myriad can be used via MSBuild as part of a your project file, or standalone by using the CLI tool. If differs from the way F# type provider works as it can produce F# types in response to other types or any arbitrary file or input, the code that is output can be examined in the development environment and can also be generated inline with your exiting code. Myriad predates C# source generators but the way it work is quite similar, Myriad was influenced somewhat by Ocaml’s Ppx code generation.\nHow does Myriad help? The idea behind Myriad is to un-complicate, as far as possible, the ability to generate code and do meta-programming in F#. By meta-programming in F# I mean generating actual F# types too, not just IL output or simple classes like type providers but outputting full F# types like discriminated unions and records.\nMyriad is an evolution of the ideas I developed while working with F#’s type providers and other meta-programming functionality like quotations and AST manipulation. Myriad aims to make it easy to extend the compiler via Myriad plugins rather than modifying or adjusting Type Providers and other F# improvements that would take a long time to be developed and released.\nThe way a Myriad plugin works is that it that works on a particular file type or input data, this could be a fragment of AST input or a proto file etc. The plugin is supplied metadata such as file name and project information. there are also various helpers in the library make it easier to produce the AST output with the final form being source code that is built into your project. The advantages of this are the compiler can optimise the generated code and the tooling can operate effectively as you can navigate the generated code as normal.\nWhat’s next for Myriad? Who knows, Im not activly writing any new features, I do check in occasionally annd merge any PR’s and answer questions.\n","description":"","tags":null,"title":"About Myriad","uri":"/myriad/"},{"content":"The following sections contain some information on how to use Myriad, we are in the process of adding new content so stay tuned!\n","description":"","tags":null,"title":"Docs","uri":"/myriad/docs/"},{"content":"","description":"","tags":null,"title":"Categories","uri":"/myriad/categories/"},{"content":"Configuration Myriad uses a configuration file called myriad.toml which uses the toml format. Myriad looks in the current directory fro this file but it can be configured by placing MyriadConfigFile in your project file like this:\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cProject Sdk=\"Microsoft.NET.Sdk\"\u003e \u003cPropertyGroup\u003e \u003cTargetFramework\u003enet6.0\u003c/TargetFramework\u003e \u003cOutputType\u003eExe\u003c/OutputType\u003e \u003cMyriadConfigFile\u003emyConfig.toml\u003c/MyriadConfigFile\u003e \u003c/PropertyGroup\u003e ... The configuration section for the built in plugins is very simple, the configuration name or key is passed in by either the plugins generator attribute, in the case of the fields plugin:\n[\u003cGenerator.Fields \"fields\"\u003e] type Test1 = { one: int; two: string; three: float; four: float32 } The configuration key is “fields”, if we now look at the myriad.toml file it looks like this:\n[fields] namespace = \"TestFields\" You can see that there is a namespace key that is set to “TestFields”. Using an attribute like this you can configure your plugin to take further information on how to generate the code.\nThere is another mechanism of specifying what configuration a plugin will use and that is by using an MSBuild property MyriadConfigKey as follows:\n\u003cCompile Include=\"ArbitaryFile.fs\"\u003e \u003cMyriadFile\u003eTest.txt\u003c/MyriadFile\u003e \u003cMyriadConfigKey\u003eexample1\u003c/MyriadConfigKey\u003e \u003c/Compile\u003e The configuration key example1 would be passed to the plugin so that it could be consumed. This is used in the Myriad.Plugin.Example1 plugin and use uses configuration to specify the namespace used.\nWriting plugins to consume configuration The plugin interface receives this key via: GeneratorContext . ConfigKey:\ntype GeneratorContext = { ConfigKey: string option ConfigGetter: string -\u003e (string * obj) seq InputFilename: string } type IMyriadGenerator = abstract member ValidInputExtensions: string seq abstract member Generate: GeneratorContext -\u003e FsAst.AstRcd.SynModuleOrNamespaceRcd list ValidInputExtensions is used so a plugin is tied to certain file types as input, if you plugin generating ast fragments from java files then you would add .java to the ValidInputExtensions implementation for example.\ninterface IMyriadGenerator with member __.ValidInputExtensions = seq {\".java\"} //... While we are discussing the IMyriadGenerator interface lets discuss the Generate member:\nGenerate takes a GeneratorContext which contains the ConfigKey as mentioned above, the ConfigGetter : string -\u003e (string * obj) seq which is a mean to allow access to the myriad.toml file, you give the function the configuration ket you wish to receive and it returns the configuration. Finally a InputFilename is also passed in so you can load or parse your input files ready to generate an AST. If you look at the included plugins you can see the mechanism for extracting and building AST fragments for reference.\n","description":"","tags":null,"title":"Configuration And Plugins","uri":"/myriad/docs/tutorials/configuration/"},{"content":"Debugging To debug Myriad, you can use the following two command line options:\n--verbose — write diagnostic logs out to standard out --wait-for-debugger — causes Myriad to wait for a debugger to attach to the Myriad process These can be triggered from msbuild by the \u003cMyriadSdkVerboseOutput\u003etrue\u003c/MyriadSdkVerboseOutput\u003e and \u003cMyriadSdkWaitForDebugger\u003etrue\u003c/MyriadSdkWaitForDebugger\u003e properties, respectively.\n","description":"","tags":null,"title":"Debugging","uri":"/myriad/docs/tutorials/debugging/"},{"content":"Using external plugins To consume external plugins that aren’t included in the Myriad.Plugins package, you must register them with Myriad. If you are using the CLI tool then the way to do this is by passing in the --plugin \u003cpath to dll\u003e command-line argument. If you are using MSBuild then this can be done by adding to the MyriadSdkGenerator property to your project file:\n\u003cItemGroup\u003e \u003cMyriadSdkGenerator Include=\"\u003cpath to plugin dll\u003e\" /\u003e \u003c/ItemGroup\u003e For example, if you had a project layout like this:\n\\src -\\GeneratorLib - Generator.fs - Generator.fsproj -\\GeneratorTests - Tests.fs - GeneratorTests.fsproj You would add the following to Generator.fsproj:\n\u003cItemGroup\u003e \u003cContent Include=\"build\\Generator.props\"\u003e \u003cPack\u003etrue\u003c/Pack\u003e \u003cPackagePath\u003e%(Identity)\u003c/PackagePath\u003e \u003cVisible\u003etrue\u003c/Visible\u003e \u003c/Content\u003e \u003c/ItemGroup\u003e Then add a new folder build with the Generator.props file within:\n\u003cProject\u003e \u003cItemGroup\u003e \u003cMyriadSdkGenerator Include=\"$(MSBuildThisFileDirectory)/../lib/netstandard2.1/Generator.dll\" /\u003e \u003c/ItemGroup\u003e \u003c/Project\u003e Often an additional props file (In this smaple the file would be Generator.InTest.props) is used to make testing easier. The matching element for the tests fsproj would be something like this:\n\u003cProject\u003e \u003cItemGroup\u003e \u003cMyriadSdkGenerator Include=\"$(MSBuildThisFileDirectory)/../bin/$(Configuration)/netstandard2.1/Generator.dll\" /\u003e \u003c/ItemGroup\u003e \u003c/Project\u003e Notice the Include path is pointing locally rather than within the packaged nuget folder structure.\nIn your testing fsproj you would add the following to allow the plugin to be used locally rather that having to consume a nuget package:\n\u003c!-- include plugin --\u003e \u003cImport Project=\"\u003cPath to Generator plugin location\u003e\\build\\Myriad.Plugins.InTest.props\" /\u003e ","description":"","tags":null,"title":"External Plugins","uri":"/myriad/docs/tutorials/external-plugins/"},{"content":"\nThere is currently an introduction to Myriad and a How to guide on creating a simple generator\nApplied Metaprogramming with Myriad and Falanx - This is a video I made for my YouTube channel which covers some details on Myriad.\nMyriad Intro - This is a blog post I wrote around the time of Applied Metaprogramming with Myriad and Falanx which has details of making a generator that produces this simple module:\nmodule example1 = let fourtyTwo = 42 ","description":"","tags":null,"title":"External resources","uri":"/myriad/docs/external-resources/"},{"content":"MSBuild usage Plugins for Myriad are supplied by simply including the nuget package in your project, the nuget infrastructure supplies the necessary MSBuild props and targets so that the plugin is used by Myriad automatically. Following the source for the fields plugin can be used as reference until more details about authoring plugins is created.\nTo use Myriad via its MSBuild support you add the Myriad.Core and Myriad.Sdk package references:\n\u003cItemGroup\u003e \u003cPackageReference Include=\"Myriad.Core\" Version=\"0.5.1\" /\u003e \u003cPackageReference Include=\"Myriad.Sdk\" Version=\"0.5.1\" /\u003e \u003cPackageReference Include=\"Myriad.Plugins\" Version=\"0.5.1\" /\u003e \u003c!-- Built in set of plugins --\u003e \u003c/ItemGroup\u003e An input file is specified by using the usual Compile element:\n\u003cCompile Include=\"Generated.fs\"\u003e \u003cMyriadFile\u003eLibrary.fs\u003c/MyriadFile\u003e \u003c/Compile\u003e This is configuring Myriad so that a file called Generated.fs will be included in the build using Library.fs as input.\nMyriad works by using plugins to generate code. A plugin called fields is included with Myriad which takes inspiration from OCamls ppx_fields_conv plugin of the same name. There are also plugins included to generate discriminated union helpers adn record lenses.\n","description":"","tags":null,"title":"MSBuild usage","uri":"/myriad/docs/tutorials/msbuild-usage/"},{"content":"Theres nothing here yet but on each new release Im hoping to add new content as the new features develop.\n","description":"","tags":null,"title":"News","uri":"/myriad/blog/"},{"content":"","description":"","tags":null,"title":"Tags","uri":"/myriad/tags/"}]